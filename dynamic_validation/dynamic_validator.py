import json
import os
from pprint import pprint
import sys
from textx import metamodel_from_file, TextXError, TextXSyntaxError

class dynamicValidation():
    
    def __init__(self, _req_json, _tx_grammar, _dynamic_grammar, _results_dir ="Results"):
        self.req_json = _req_json
        self.tx_grammar_file = _tx_grammar
        self.dynamic_grammar = _dynamic_grammar 
        self.results_dir = _results_dir

    def startValidation(self):
        """
        1. Read individual lines from the LLM generated json
        2. For each line create a specification document (in this case the dynamic_grammar file is updated everytime)
        3. Validate the dynamic_grammar file (against LESS grammar)
        4. When errors occur, log them. Also log successful validations
        
        This whole process is required because it seems that there is no way to allow textX grammar to move past errors. It will stop at any error.
        
        The program therefore checks which LESS specifications were correclty generated and which were incorrect.
        
        This is then the "Validation" of the generated LESS grammar to judge performance of the LLM
        """
        validation_errors = []
        correct_lines = []
        
        
        # Load JSON data
        #there is no need to load json_data now because it is already in json
        #json_data = self.load_json(self.req_json)
        json_data = json.loads(self.req_json)

        line_count = 0
        for item in json_data:
            line_count = line_count + 1
            less_line = item['LESS']

            updated_content = self.replace_line_in_tx(less_line, self.dynamic_grammar)

            # Validate updated tx file
            #print(updated_content)
            error = self.validate_tx(updated_content, self.tx_grammar_file)
            if error:
                validation_errors.append({"Line_number": line_count , "LESS": less_line, "Error": error})
            else:
                correct_lines.append({"Line_number": line_count ,"LESS": less_line})
 
        #with open(os.path.join(self.results_dir, 'validation_errors.json'), 'w') as f:
        #    json.dump(validation_errors, f, indent=4)

        #with open(os.path.join(self.results_dir, 'correct_lines.json'), 'w') as f:
        #    json.dump(correct_lines, f, indent=4)
        return  validation_errors, correct_lines

    # Load LLM generated JSON file
    def load_json(self, file_path):
        with open(file_path, 'r') as f:
            return json.load(f)

    # Replace the line in the dynamic.txt file
    def replace_line_in_tx(self, less_line, tx_file_path):
        with open(tx_file_path, 'r') as f:
            tx_content = f.readlines()

        self.updated_lines = []
        inside_requirements = False
        skip_block = False
        for line in tx_content:
            if "RequirementClassification: SecurityFunctional" in line:
                inside_requirements = True
                self.updated_lines.append(line)
            elif inside_requirements and "{" in line:
                # replace the less requirement in the dynamic_grammar file with the less line that is read
                self.updated_lines.append(f"\t\t\t{{\n\t\t\t\t{less_line}\n\t\t\t}}\n")
                skip_block = True  # Skip until the closing '}'
            elif inside_requirements and "}" in line and skip_block:
                skip_block = False
                inside_requirements = False
            elif not skip_block:
                self.updated_lines.append(line)

        return ''.join(self.updated_lines)

    # Validate the txt file ussing the tx grammar that specified less
    def validate_tx(self, txt_content, tx_grammar_file):
        try:
            mm = metamodel_from_file(tx_grammar_file)
            a = mm.model_from_str(txt_content)
            # pprint(vars(a.requirements[0].req.specification))
            # print("____")
            #pprint(vars(a.requirements[0].req.specification.conditionals))
            # print((a.requirements[0].req.specification.conditionals.condition[0].lit))
            #pprint(vars(a))
            return None  # No errors
        except TextXError as e:
            return str(e)

# Main execution
if __name__ == "__main__":
    #json file that is generated by the llm, this file will be validated
    req_json = r"D:\FOKUS\LESS\src\LESS_Req_Generation\Results\OUTPUT-LLAMA.json"

    #the less grammar file, this will be used for validation
    tx_grammar_file = r"D:\FOKUS\LESS\grammar\less.tx"

    #dynamic grammar file that will be updated in each iteration. the less requirement in this file will be replaced by the LESS attribute content from the llm generated file
    dynamic_grammar = r"D:\FOKUS\LESS\grammar\dynamic_grammar.txt"
    
    dv = dynamicValidation(req_json, tx_grammar_file, dynamic_grammar)
    validation_errors, correct_lines = dv.startValidation()
    # Print validation errors
    if validation_errors:
        print("Validation Errors:")
        for error in validation_errors:
            print(f"Line{error['Line_number']}, LESS: {error['LESS']}, Error: {error['Error']}")
    else:
        print("All LESS lines processed and validated successfully.")
            